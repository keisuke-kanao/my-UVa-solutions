
/*
	UVa 10515 - Powers Et Al.

	To build using Visual Studio 2008:
		cl -EHsc -O2 -DONLINE_JUDGE UVa_10515_Powers_Et_Al.cpp

	For explanation, see UVa 10515 - Algorithmist (http://www.algorithmist.com/index.php/UVa_10515).
		Oddly enough you only need the last digit of the first number and the last two digits of the second number.
*/

#include <iostream>
#include <string>
using namespace std;

#ifdef ONLINE_JUDGE

int modpowers[9 - 0 + 1][100 - 0 + 1] = { // modpowers[i][j] is the power(i, j) mod 10
{1, // base = 0
0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
},
{1, // base = 1
1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
},
{1, // base = 2
2, 4, 8, 6, 2, 4, 8, 6, 2, 4,
8, 6, 2, 4, 8, 6, 2, 4, 8, 6,
2, 4, 8, 6, 2, 4, 8, 6, 2, 4,
8, 6, 2, 4, 8, 6, 2, 4, 8, 6,
2, 4, 8, 6, 2, 4, 8, 6, 2, 4,
8, 6, 2, 4, 8, 6, 2, 4, 8, 6,
2, 4, 8, 6, 2, 4, 8, 6, 2, 4,
8, 6, 2, 4, 8, 6, 2, 4, 8, 6,
2, 4, 8, 6, 2, 4, 8, 6, 2, 4,
8, 6, 2, 4, 8, 6, 2, 4, 8, 6,
},
{1, // base = 3
3, 9, 7, 1, 3, 9, 7, 1, 3, 9,
7, 1, 3, 9, 7, 1, 3, 9, 7, 1,
3, 9, 7, 1, 3, 9, 7, 1, 3, 9,
7, 1, 3, 9, 7, 1, 3, 9, 7, 1,
3, 9, 7, 1, 3, 9, 7, 1, 3, 9,
7, 1, 3, 9, 7, 1, 3, 9, 7, 1,
3, 9, 7, 1, 3, 9, 7, 1, 3, 9,
7, 1, 3, 9, 7, 1, 3, 9, 7, 1,
3, 9, 7, 1, 3, 9, 7, 1, 3, 9,
7, 1, 3, 9, 7, 1, 3, 9, 7, 1,
},
{1, // base = 4
4, 6, 4, 6, 4, 6, 4, 6, 4, 6,
4, 6, 4, 6, 4, 6, 4, 6, 4, 6,
4, 6, 4, 6, 4, 6, 4, 6, 4, 6,
4, 6, 4, 6, 4, 6, 4, 6, 4, 6,
4, 6, 4, 6, 4, 6, 4, 6, 4, 6,
4, 6, 4, 6, 4, 6, 4, 6, 4, 6,
4, 6, 4, 6, 4, 6, 4, 6, 4, 6,
4, 6, 4, 6, 4, 6, 4, 6, 4, 6,
4, 6, 4, 6, 4, 6, 4, 6, 4, 6,
4, 6, 4, 6, 4, 6, 4, 6, 4, 6,
},
{1, // base = 5
5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
},
{1, // base = 6
6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
},
{1, // base = 7
7, 9, 3, 1, 7, 9, 3, 1, 7, 9,
3, 1, 7, 9, 3, 1, 7, 9, 3, 1,
7, 9, 3, 1, 7, 9, 3, 1, 7, 9,
3, 1, 7, 9, 3, 1, 7, 9, 3, 1,
7, 9, 3, 1, 7, 9, 3, 1, 7, 9,
3, 1, 7, 9, 3, 1, 7, 9, 3, 1,
7, 9, 3, 1, 7, 9, 3, 1, 7, 9,
3, 1, 7, 9, 3, 1, 7, 9, 3, 1,
7, 9, 3, 1, 7, 9, 3, 1, 7, 9,
3, 1, 7, 9, 3, 1, 7, 9, 3, 1,
},
{1, // base = 8
8, 4, 2, 6, 8, 4, 2, 6, 8, 4,
2, 6, 8, 4, 2, 6, 8, 4, 2, 6,
8, 4, 2, 6, 8, 4, 2, 6, 8, 4,
2, 6, 8, 4, 2, 6, 8, 4, 2, 6,
8, 4, 2, 6, 8, 4, 2, 6, 8, 4,
2, 6, 8, 4, 2, 6, 8, 4, 2, 6,
8, 4, 2, 6, 8, 4, 2, 6, 8, 4,
2, 6, 8, 4, 2, 6, 8, 4, 2, 6,
8, 4, 2, 6, 8, 4, 2, 6, 8, 4,
2, 6, 8, 4, 2, 6, 8, 4, 2, 6,
},
{1, // base = 9
9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
},
};

int last_digit_of_exponent(int base, int power)
{
	return modpowers[base][power];
}

#else

int last_digit_of_exponent(int base, int power)
{
	if (!power)
		return 1;
	else if (!(power & 1)) {
		int n = last_digit_of_exponent(base, power >> 1) % 10;
		return (n * n) % 10;
	}
	else {
		return ((base % 10) * (last_digit_of_exponent(base, power - 1) % 10)) % 10;
	}
}

#endif

bool is_zero(const char* p)
{
	for ( ; *p; p++)
		if (*p != '0')
			return false;
	return true;
}

int main()
{
	while (true) {
		string sm, sn;
		cin >> sm >> sn;
		if (is_zero(sm.c_str()) && is_zero(sn.c_str()))
			break;
		size_t sm_length = sm.length(), sn_length = sn.length();
		int m = sm[sm_length - 1] - '0';
		int n = (sn_length > 1) ? (sn[sn_length - 2] - '0') * 10 : 0;
		n += sn[sn_length - 1] - '0';
		if (!n && sn_length > 2)
			n = 100;
		cout << last_digit_of_exponent(m, n) << endl;
	}
	return 0;
}

